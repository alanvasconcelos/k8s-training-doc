
Bootstrap tokens are a simple bearer token that is meant to be used when creating new clusters or joining new nodes to an existing cluster. It was built to support kubeadm, but can be used in other contexts for users that wish to start clusters without kubeadm. It is also built to work, via RBAC policy, with the Kubelet TLS Bootstrapping system.

https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/

Bootstrap Tokens take the form of abcdef.0123456789abcdef. More formally, they must match the regular expression [a-z0-9]{6}\.[a-z0-9]{16}

https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md

Implementation Flow
kubeadm will implement the following flow:

kubeadm connects to the API server address specified over TLS. As we don't yet have a root certificate to trust, this is an insecure connection and the server certificate is not validated. kubeadm provides no authentication credentials at all.

Implementation note: the API server doesn't have to expose a new and special insecure HTTP endpoint.

(D)DoS concern: Before this flow is secure to use/enable publicly (when not bootstrapping), the API Server must support rate-limiting. There are a couple of ways rate-limiting can be implemented to work for this use-case, but defining the rate-limiting flow in detail here is out of scope. One simple idea is limiting unauthenticated requests to come from clients in RFC1918 ranges.

kubeadm requests a ConfigMap containing the kubeconfig file defined above.
This ConfigMap exists at a well known URL: https://<server>/api/v1/namespaces/kube-public/configmaps/cluster-info

This ConfigMap is really public. Users don't need to authenticate to read this ConfigMap. In fact, the client MUST NOT use a bearer token here as we don't trust this endpoint yet.

The API server returns the ConfigMap with the kubeconfig contents as normal
Extra data items on that ConfigMap contains JWS signatures. kubeadm finds the correct signature based on the token-id part of the token. (Described below).

kubeadm verifies the JWS and can now trust the server. Further communication is simpler as the CA certificate in the kubeconfig file can be trusted.


API Server

/etc/systemd/system/kube-apiserver.service


--client-ca-file=/var/lib/kubernetes/ca.pem
--enable-bootstrap-token-auth=true

kube-controller-manager

/etc/systemd/system/kube-controller-manager.service

--controllers=*,bootstrapsigner,tokencleaner
--cluster-signing-cert-file=/var/lib/kubernetes/ca.pem
--cluster-signing-key-file=/var/lib/kubernetes/ca-key.pem
--experimental-cluster-signing-duration=8760h0m0s

To allow kubelet to create CSR

cat <<EOF | kubectl create -f -
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: create-csrs-for-bootstrapping
subjects:
- kind: Group
  name: system:bootstrappers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:node-bootstrapper
  apiGroup: rbac.authorization.k8s.io
EOF

CSR auto signing for bootstrapper

$ cat <<EOF | kubectl create -f -
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: auto-approve-csrs-for-group
subjects:
- kind: Group
  name: system:bootstrappers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
  apiGroup: rbac.authorization.k8s.io
EOF

certificates self renewal

cat <<EOF | kubectl create -f -
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: auto-approve-renewals-for-nodes
subjects:
- kind: Group
  name: system:nodes
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
  apiGroup: rbac.authorization.k8s.io
EOF

Create bootstrap token

$ TOKEN_ID=$(openssl rand -hex 3)
$ TOKEN_SECRET=$(openssl rand -hex 8)
$ BOOTSTRAP_TOKEN="${TOKEN_ID}.${TOKEN_SECRET}"
$ echo $BOOTSTRAP_TOKEN
14f2fc.98e93207235685a1


bootstrap-token.yaml

apiVersion: v1
kind: Secret
metadata:
  # Name MUST be of form "bootstrap-token-<token id>"
  name: bootstrap-token-14f2fc
  namespace: kube-system

# Type MUST be 'bootstrap.kubernetes.io/token'
type: bootstrap.kubernetes.io/token
stringData:
  # Human readable description. Optional.
  description: "The default bootstrap token generated by 'kubeadm init'."

  # Token ID and secret. Required.
  token-id: 14f2fc
  token-secret: 98e93207235685a1

  # Expiration. Optional.
  expiration: 2018-12-05T12:00:00Z

  # Allowed usages.
  usage-bootstrap-authentication: "true"
  usage-bootstrap-signing: "true"

  # Extra groups to authenticate the token as. Must start with "system:bootstrappers:"
  auth-extra-groups: system:bootstrappers:worker,system:bootstrappers:ingress

kubectl create -f bootstrap-token.yaml


Create cluster-info

$ kubectl config set-cluster bootstrap \
  --kubeconfig=bootstrap-kubeconfig  \
  --server='https://10.240.0.10:6443' \
  --certificate-authority=/var/lib/kubernetes/ca.pem \
  --embed-certs=true

$ kubectl -n kube-public create configmap cluster-info \
  --from-file=kubeconfig=bootstrap-kubeconfig

kubectl -n kube-public get configmap cluster-info -o yaml


Create bootstrap-kubeconfig

worker:~$ kubectl config set-cluster bootstrap \
  --kubeconfig=bootstrap-kubeconfig \
  --server='https://10.240.0.10:6443' \
  --certificate-authority=ca.pem \
  --embed-certs=true

worker:~$ kubectl config set-credentials kubelet-bootstrap \
  --kubeconfig=bootstrap-kubeconfig \
  --token=14f2fc.98e93207235685a1

worker:~$ kubectl config set-context bootstrap \
  --kubeconfig=bootstrap-kubeconfig \
  --user=kubelet-bootstrap \
  --cluster=bootstrap

worker:~$ kubectl config --kubeconfig=bootstrap-kubeconfig use-context bootstrap
worker:~$ sudo mv bootstrap-kubeconfig /var/lib/kubelet/  

/etc/systemd/system/kubelet.service


--bootstrap-kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig
--cert-dir=/var/lib/kubelet/
--kubeconfig=/var/lib/kubelet/kubeconfig
--rotate-certificates=true

worker:~$ sudo systemctl daemon-reload
worker:~$ sudo systemctl start kubelet
